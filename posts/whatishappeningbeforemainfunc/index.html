<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>What happens before the main function, from the _start point to the main function? | BitInfiltrator</title>
<meta name=keywords content="binary,ELF File Format,GCC,Reverse Engineering"><meta name=description content="Introducion
For most programmers, the entry point of a C or C++ program is the main function. However, they may be unaware of the complex steps that occur before main is executed. Depending on the program and the compiler used, various functions may run before main. These functions are automatically included in the final executable binary by the compiler and linker, but they remain hidden from the programmer.
This post discusses the execution process and events from _start to the main function, with future posts covering the next steps."><meta name=author content="Mahdi Davoudabadi"><link rel=canonical href=https://bitinfiltrator.github.io/posts/whatishappeningbeforemainfunc/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://bitinfiltrator.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://bitinfiltrator.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://bitinfiltrator.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://bitinfiltrator.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://bitinfiltrator.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bitinfiltrator.github.io/posts/whatishappeningbeforemainfunc/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://bitinfiltrator.github.io/posts/whatishappeningbeforemainfunc/"><meta property="og:site_name" content="BitInfiltrator"><meta property="og:title" content="What happens before the main function, from the _start point to the main function?"><meta property="og:description" content="Introducion For most programmers, the entry point of a C or C++ program is the main function. However, they may be unaware of the complex steps that occur before main is executed. Depending on the program and the compiler used, various functions may run before main. These functions are automatically included in the final executable binary by the compiler and linker, but they remain hidden from the programmer.
This post discusses the execution process and events from _start to the main function, with future posts covering the next steps."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-25T13:11:18+00:00"><meta property="article:modified_time" content="2025-01-25T13:11:18+00:00"><meta property="article:tag" content="Binary"><meta property="article:tag" content="ELF File Format"><meta property="article:tag" content="GCC"><meta property="article:tag" content="Reverse Engineering"><meta property="og:image" content="https://bitinfiltrator.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bitinfiltrator.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="What happens before the main function, from the _start point to the main function?"><meta name=twitter:description content="Introducion
For most programmers, the entry point of a C or C++ program is the main function. However, they may be unaware of the complex steps that occur before main is executed. Depending on the program and the compiler used, various functions may run before main. These functions are automatically included in the final executable binary by the compiler and linker, but they remain hidden from the programmer.
This post discusses the execution process and events from _start to the main function, with future posts covering the next steps."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bitinfiltrator.github.io/posts/"},{"@type":"ListItem","position":2,"name":"What happens before the main function, from the _start point to the main function?","item":"https://bitinfiltrator.github.io/posts/whatishappeningbeforemainfunc/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"What happens before the main function, from the _start point to the main function?","name":"What happens before the main function, from the _start point to the main function?","description":"Introducion For most programmers, the entry point of a C or C++ program is the main function. However, they may be unaware of the complex steps that occur before main is executed. Depending on the program and the compiler used, various functions may run before main. These functions are automatically included in the final executable binary by the compiler and linker, but they remain hidden from the programmer.\nThis post discusses the execution process and events from _start to the main function, with future posts covering the next steps.\n","keywords":["binary","ELF File Format","GCC","Reverse Engineering"],"articleBody":"Introducion For most programmers, the entry point of a C or C++ program is the main function. However, they may be unaware of the complex steps that occur before main is executed. Depending on the program and the compiler used, various functions may run before main. These functions are automatically included in the final executable binary by the compiler and linker, but they remain hidden from the programmer.\nThis post discusses the execution process and events from _start to the main function, with future posts covering the next steps.\nBefore we dive into the main part, you must have some basic knowledge about constructor and destructors.\nHow does GCC handle constructor and destructor functions? In C++, dynamic initialization of non-local variables is performed before the first main function statement is executed. In other words, these variables are initialized before the main program starts running. All (or most) C++ compiler implementations guarantee this.\nThe GCC compiler supports __attribute__((constructor)), which allows you to call an arbitrary function before the main function is executed. These functions, called constructors, can have an optional precedence specified using __attribute__((constructor(N))).\nPriorities ranging from 0 to 100 are reserved for internal compiler use, and utilizing them will trigger the -Wprio-ctor-dtor warning. For instance, the gcov tool uses the attribute __attribute__((destructor(100))). Programmers can use priorities from 101 to 65535 for their constructor functions. The priority 65535, specified by the .init_array or .ctors sections without an extension, is the default priority for the dynamic initialization of non-local variables.\n#include __attribute__((constructor(102))) void init102() { puts(\"init102\"); } __attribute__((constructor(101))) void init101() { puts(\"init101\"); } __attribute__((constructor)) void init() { puts(\"init65535\"); } int main(void) { return 0; } Constructor functions on ELF platforms are implemented in two ways: the older method uses .init/.ctors, while the newer method utilizes .init_array.\n.ctors and .dtors Sections In GCC’s libgcc/crtstuff.c, when __LIBGCC_INIT_ARRAY_SECTION_ASM_OP__ is not defined and __LIBGCC_INIT_SECTION_ASM_OP__ is defined (indicating that HAVE_INITFINI_ARRAY_SUPPORT is 1 in $builddir/gcc/auto-host.h), the following scheme is used. Note that this condition is not met on modern systems.\nC++ dynamic initializations and __attribute__((constructor)) do not use _init directly.When this condition is met, global constructors and destructors are stored in sections known as .ctors and .dtors, respectively. These sections contain the addresses of these functions, and at runtime, the operating system retrieves these addresses and executes the functions in the specified order. In essence, these sections act as a list of functions that must be called before and after the main program begins execution.\nImagine we have two object files named c.o and d.o, each containing a .ctors section with different priorities. After linking these files, the resulting .ctors section will be organized as follows:\ncrtbegin.o:(.ctors) __CTOR_LIST__\rc.o:(.ctors) d.o:(.ctors)\rc.o:(.ctors.00001) d.o:(.ctors.00001)\rc.o:(.ctors.00002) d.o:(.ctors.00002)\r...\rc.o:(.ctors.65533) d.o:(.ctors.65533)\rc.o:(.ctors.65534) d.o:(.ctors.65534)\r...\rcrtend.o:(.ctors) __CTOR_LIST_END__ The .dtors section is organized in the same manner:\ncrtbegin.o:(.dtors) __DTOR_LIST__\rc.o:(.dtors) d.o:(.dtors)\rc.o:(.dtors.00001) d.o:(.dtors.00001)\rc.o:(.dtors.00002) d.o:(.dtors.00002)\r...\rc.o:(.dtors.65533) d.o:(.dtors.65533)\rc.o:(.dtors.65534) d.o:(.dtors.65534)\r...\rcrtend.o:(.dtors) __DTOR_LIST_END__ The crtbegin.o and crtend.o files play a crucial role in the initialization and termination processes of a program. These files contain specific functions and data that the linker includes in the final executable file.\nThe crtbegin.o file:\nAt the beginning of each .ctors and .dtors section, it places a special value known as the guard element. This value is typically -1 (or its equivalent on 64-bit systems, 0xffffffffffffffff) and indicates the start of the list of constructors or destructors. The crtbegin.o file also defines a .fini section that calls the __do_global_dtors_aux function. This function is responsible for executing static destructors (functions that free resources) in the correct order. The crtend.o file:\nAt the end of each .ctors and .dtors section, it places a special value called the guard element. This value is usually 0, which signifies the end of the constructor or destructor list. The crtend.o file also defines an .init section that calls the __do_global_ctors_aux function. This function is responsible for executing static constructors (functions that initialize variables and objects) in the correct order. The guard elements (-1 and 0) serve as markers to help the linker and operating system identify the beginning and end of the lists of constructors and destructors, respectively. These elements are ignored when the functions are executed.\nReverse Execution Order of Constructors and Destructors One interesting feature of constructor and destructor execution is their reverse order of execution. Specifically, constructors located in the .ctors section are executed in reverse order, while destructors in the .dtors section are executed in the order in which they were defined.\nWhy Are Constructors Executed in Reverse Order? This behavior is by design. When dynamically linking libraries, if one library depends on another, the constructors of the dependent library are executed first. For example, if library a.so depends on library b.so, the constructors of b.so are executed before those of a.so. This sequence ensures that each symbol is properly initialized before being used.\nFor .ctors sections without an extension (which have the lowest precedence), the order of constructor execution during dynamic linking follows the same pattern as in static linking. This means that when multiple object files are linked together into an executable, the constructors are executed in the order they appear on the command line.\nDestructors serve as a complement to constructors, executing in the order of their creation. This ensures that resources are properly deallocated in the reverse order of how they were allocated.\nWhy Is This Order Important? It ensures that each symbol is initialized before use. It maintains consistent behavior between dynamic and static linking. It guarantees the correct deallocation of resources. .init_array and .fini_array Sections The developers of HP-UX identified several issues with the use of the .init and .ctors sections:\nThe _init function is fragmented and inconsistent, resulting in code that is difficult to read and prone to errors. Using sentinel values in the .ctors section is considered poor practice. The .init and .ctors sections utilize unconventional naming instead of the defined section types. To address these issues, the DT_INIT_ARRAY mechanism was introduced as an alternative. While glibc implemented this method in 1999, both GCC and Binutils had outdated implementations at that time.\nSupport for DT_INIT_ARRAY was added to FreeBSD in March 2012, to OpenBSD in August 2016, and to all ports of NetBSD in December 2018.\nIn the glibc and BSD implementations, the constructors are invoked with argc, argv, and environ arguments. In contrast, the musl implementation calls constructors without any arguments.\nIn this context, the .init_array and .init_array.N sections are designated as type SHT_INIT_ARRAY. Note that crtbegin.o and crtend.o do not provide any segments.\nThe layout is as follows:\na.o:(.init_array.1) b.o:(.init_array.1)\ra.o:(.init_array.2) b.o:(.init_array.2)\r...\ra.o:(.init_array.65533) b.o:(.init_array.65533)\ra.o:(.init_array.65534) b.o:(.init_array.65534)\ra.o:(.init_array) b.o:(.init_array) The linker defines DT_INIT_ARRAY and DT_INIT_ARRAYSZ based on the address and size of init_array. It also defines init_array_start and init_array_end if they are referenced. These pair of symbols can be used by a statically linked, position-dependent executable that may not include a .dynamic section.\nUnlike .ctors, the execution order of .init_array is linear, following .init. Specifically, the order of execution for a.o:(.init_array) b.o:(.init_array) is different from a.o:(.ctors) b.o:(.ctors).\nIn the GCC compiler, newer ABI implementations, such as AArch64 and RISC-V, exclusively use .init_array and do not include .ctors.\n.preinit_array The linker determines the values of DT_PREINIT_ARRAY and DT_PREINIT_ARRAYSZ based on the address and size of the .preinit_array section. It also defines the symbols __preinit_array_start and __preinit_array_end if they are referenced.\nDT_PREINIT_ARRAY contains the address of an array of pointers to pre-initialization functions. The DT_PREINIT_ARRAY table is processed only in executable files and is ignored in shared objects. This feature allows the executable file to run initialization functions before any shared object dependencies are processed. There is no .postfini_array.\nMost implementations of ld.so support DT_PREINIT_ARRAY; however, musl does not support this feature.\nWhat is happening behind the scene? Let’s review the previously written program. This program contains three functions that execute before the main execution and display the corresponding messages. Additionally, the main function in this program does nothing but return 0.\n#include __attribute__((constructor(102))) void init102() { puts(\"init102\"); } __attribute__((constructor(101))) void init101() { puts(\"init101\"); } __attribute__((constructor)) void init() { puts(\"init65535\"); } int main(void) { return 0; } To include debug information for analysis in our program, we must compile it using the -ggdb switch of the gcc compiler. You can achieve this with the following command:\ngcc -ggdb -o ELF2 ELF_008.c What is the difference between the -g and -ggdb switches?\nThe -g switch instructs the compiler to generate debugging information in standard operating system formats such as stabs, COFF, XCOFF, or DWARF. This information helps debugging tools like GDB to better understand and debug the program.\nThe -ggdb switch produces a more comprehensive level of debugging information specifically designed for GDB. This allows GDB to extract additional information about the program, enabling more detailed debugging.\nBefore we debug the program in gdb, let’s first examine how a C program is executed from the beginning. We can use the objdump tool to convert machine code into assembly code. The following command saves the disassembly output of an ELF2 program to a file named ELF2.dump:\nobjdump -d ELF2 \u003e ELF2.dump The file named prog1.dump contains assembly instructions that the processor executes directly. Here is a brief overview of the functions that we will review shortly:\nELF2: file format elf64-x86-64\r0000000000001050 \u003c_start\u003e:\r1050:\t31 ed xor %ebp,%ebp\r1052:\t49 89 d1 mov %rdx,%r9\r1055:\t5e pop %rsi\r1056:\t48 89 e2 mov %rsp,%rdx\r1059:\t48 83 e4 f0 and $0xfffffffffffffff0,%rsp\r105d:\t50 push %rax\r105e:\t54 push %rsp\r105f:\t45 31 c0 xor %r8d,%r8d\r1062:\t31 c9 xor %ecx,%ecx\r1064:\t48 8d 3d 10 01 00 00 lea 0x110(%rip),%rdi # 117b 106b:\tff 15 4f 2f 00 00 call *0x2f4f(%rip) # 3fc0 \u003c__libc_start_main@GLIBC_2.34\u003e\r1071:\tf4 hlt\r1072:\t66 2e 0f 1f 84 00 00 cs nopw 0x0(%rax,%rax,1)\r1079:\t00 00 00 107c:\t0f 1f 40 00 nopl 0x0(%rax)\r0000000000001139 :\r1139:\t55 push %rbp\r113a:\t48 89 e5 mov %rsp,%rbp\r113d:\t48 8d 05 c0 0e 00 00 lea 0xec0(%rip),%rax # 2004 \u003c_IO_stdin_used+0x4\u003e\r1144:\t48 89 c7 mov %rax,%rdi\r1147:\te8 e4 fe ff ff call 1030 114c:\t90 nop\r114d:\t5d pop %rbp\r114e:\tc3 ret\r000000000000114f :\r114f:\t55 push %rbp\r1150:\t48 89 e5 mov %rsp,%rbp\r1153:\t48 8d 05 b2 0e 00 00 lea 0xeb2(%rip),%rax # 200c \u003c_IO_stdin_used+0xc\u003e\r115a:\t48 89 c7 mov %rax,%rdi\r115d:\te8 ce fe ff ff call 1030 1162:\t90 nop\r1163:\t5d pop %rbp\r1164:\tc3 ret\r0000000000001165 :\r1165:\t55 push %rbp\r1166:\t48 89 e5 mov %rsp,%rbp\r1169:\t48 8d 05 a4 0e 00 00 lea 0xea4(%rip),%rax # 2014 \u003c_IO_stdin_used+0x14\u003e\r1170:\t48 89 c7 mov %rax,%rdi\r1173:\te8 b8 fe ff ff call 1030 1178:\t90 nop\r1179:\t5d pop %rbp\r117a:\tc3 ret\r000000000000117b :\r117b:\t55 push %rbp\r117c:\t48 89 e5 mov %rsp,%rbp\r117f:\tb8 00 00 00 00 mov $0x0,%eax\r1184:\t5d pop %rbp\r1185:\tc3 ret\r... The _start Function: The Hidden Beginning of a Program In most C and C++ programs, the actual starting point of execution is a function called _start. This function is responsible for setting up the program’s execution environment and for calling the main function, which serves as the logical starting point for the programmer.\nWhile it is a common convention to use _start as the main entry point, it is not a strict requirement. Depending on the operating system, compiler, and libraries utilized, a different entry point may be specified. For instance, on macOS, the main function itself serves as the entry point, with the operating system taking care of preparing the execution environment.\nThe linker plays a crucial role in determining a program’s entry point. By default, linkers such as Clang and GCC set the entry point to the _start function. However, this can be altered using the -e switch, although such changes are typically unnecessary.\nThe _start function is usually implemented and provided in the C standard library (libc) and is often written in assembly language. This code is found in a file named crt0.s, and compilers generally provide precompiled versions of this file for various architectures.\nHow do we get to _start? When you run a Linux program, the shell or graphical user interface (GUI) calls the execve() function, which executes the Linux execve() system call.\nint execve(const char *pathname, char *const _Nullable argv[], char *const _Nullable envp[]); The execve function replaces the currently running program with the program specified by the pathname. The current program is the process that invoked the execve system call, which in this case is the shell or GUI. In other words, the new program takes the place of the previous one, creating a new memory space for itself, which includes a stack, heap, and data sections (both initialized and uninitialized).\nThe pathname must be an executable binary file or a script that begins with a line in the following format:\n#!interpreter [optional-arg] The argv variable is an array containing the arguments provided on the command line when running the program. Each element of this array is a string representing an argument. For instance, if we run a program called myprogram with the arguments -a and data.txt, the argv array will look like this:\nargv[0] = \"myprogram\";\rargv[1] = \"-a\";\rargv[2] = \"data.txt\";\rargv[3] = NULL; The envp variable is an array of pointers to strings that contains environment variables passed to the new program. These environment variables function like system variables, and each element of this array is a string formatted as key=value. For example:\nenvp[0] = \"PATH=/bin:/usr/bin\";\renvp[1] = \"HOME=/home/user\";\renvp[2] = NULL; When execve is successfully executed, the new program completely replaces the previous one, and all the resources of the previous program are freed. This means that the execve function never returns to the calling program; instead, the memory space of the previous program is replaced with that of the new program. Additionally, if the previous program is being traced (using ptrace), a SIGTRAP signal is sent to it after the successful execution of execve.\nFollowing this, the loader is responsible for loading the program into memory and setting up memory addresses. The loader may also perform some initial tasks, such as calling certain functions, before the program begins executing. Once everything is ready, control of the program execution is transferred to a function called _start.\nFor more information about the execve system call, please refer to this link.\nA Closer Look at _start First, we run the program in GDB using the following command:\ngdb ./ELF2 Next, we set a breakpoint at the beginning of the _start function and run the program:\nb _start\rr Once we reach the _start function, the program stack appears as follows:\n+-----------------+\r| NULL |\r+-----------------+ | ... |\r| envp |\r| ... |\r+-----------------+ | NULL |\r+------------------\r| ... |\r| argv |\r| ... |\r+------------------\r| argc | \u003c- rsp\r+-----------------+ Below, you can see the structure of the _start function for the program we compiled using GCC:\n● →0x555555555050 \u003c_start+0000\u003e xor ebp, ebp 0x555555555052 \u003c_start+0002\u003e mov r9, rdx 0x555555555055 \u003c_start+0005\u003e pop rsi 0x555555555056 \u003c_start+0006\u003e mov rdx, rsp 0x555555555059 \u003c_start+0009\u003e and rsp, 0xfffffffffffffff0 0x55555555505d \u003c_start+000d\u003e push rax 0x55555555505e \u003c_start+000e\u003e push rsp 0x55555555505f \u003c_start+000f\u003e xor r8d, r8d 0x555555555062 \u003c_start+0012\u003e xor ecx, ecx 0x555555555064 \u003c_start+0014\u003e lea rdi, [rip+0x110] # 0x55555555517b \u003cmain\u003e 0x55555555506b \u003c_start+001b\u003e call QWORD PTR [rip+0x2f4f] # 0x555555557fc0 0x555555555071 \u003c_start+0021\u003e hlt At the beginning of this code, the ebp register is set to zero using the xor ebp, ebp instruction. This zero value in the ebp register indicates the start of a new stack frame.\nThe value in the rdx register, which is being transferred to r9, corresponds to the dl_fini function. This function serves as a parameter to the __libc_start_main function.\nThe value of argc is removed from the top of the stack and placed into the rsi register.\nNext, the instruction mov rdx, rsp is used to transfer the address of the argv parameter into the rdx register.\nAn AND operation is then performed between the rsp register and the value 0xffffffffffffff0. The purpose of this operation is to align the stack to a 16-byte boundary. After popping the argc value from the stack, the esp value changes from 0xbffff770 to 0xbffff774. The AND operation restores the rsp value back to 0xbffff770.\nFinally, the starting address of the envp array is pushed onto the stack.\nNote that the r8 and ecx registers are for the init and fini function parameters, and these parameters are set to zero.\nIn older versions of GCC (2.34 and earlier), the parameters for init and fini were passed as the addresses of the first instructions of the functions __libc_csu_init and __libc_csu_fini, respectively. However, with changes, these two functions have been removed. The responsibilities for processing the init_array, fini_array, and preinit_array arrays have now been divided into different sections of the libc_start_main function. As a result of the removal of these functions, null values are passed to the libc_start_main function for the init and fini parameters instead of the addresses of __libc_csu_init and __libc_csu_fini.\nThe question arises: how do we determine the locations of argc, argv, and envp? Before the _start function is called, these three values are placed on the stack as pointers. To understand this, we should examine the contents of the rsp register: As it shown in the image, the value of argc is represented by the number 1, indicating that it was executed without any additional parameters. Consequently, this parameter value will be stored on the stack at the address 0x00007fffffffe1b0. If we display the value located at this address as a string, we can observe argv, and envp is placed on the stack after argv.\nAs shown in the image, the value of argc is 1, indicating that the program was executed without any additional parameters. This value will be stored on the stack at the address 0x00007fffffffe1b0. If we display the value stored at this address as a string, we can see argv, while envp is placed on the stack following argv.\nPreparing to call the libc_start_main function. At this stage, the arguments required for the libc_start_main function call are pushed onto the stack in reverse order. The first argument placed on the stack is an arbitrary value, typically stored in the rax register. This value is pushed onto the stack solely for the purpose of maintaining 16-byte alignment and serves no other function. It is essential to maintain this alignment because the subsequent arguments are pushed onto the stack in order, and the additional value ensures proper memory alignment.\nThe structure of the __libc_start_main function is as follows:\nint __libc_start_main( int (*main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end)); So, the _start function is expected to push this argument onto the stack in reverse order. The register values before the call looks like this:\nregisters values rdi a pointer to the first instruction of the main function rsi argc value rdx pointer to argv rcx null value r8 null value r9 a pointer to the dl_fini/rtld_fini function Where are the environment variables (envp)? As mentioned, the envp array is stored on the stack right after the argv array. By using argc, we can determine the number of elements in the argv array, which allows us to find the end of this array and access the envp array. In the image below,at line 244, you can see how __libc_start_main extracts envp at the source code level:\nAfter that, you can see that the pointer to the environment variables is stored in a variable named __environ. This variable is accessible throughout the program and is utilized by other C library functions to access environment variables. Whenever libc_start_main requires it—such as when it calls the main function it can reference __environ. Additionally, there’s another vector following the envp array known as the ELF auxiliary vector. The loader uses this vector to provide various information to our process. You can view this information by using the command LD_SHOW_AUXV=1:\nLD_SHOW_AUXV=1 ./ELF2\rAT_SYSINFO_EHDR: 0x7f7134737000\rAT_MINSIGSTKSZ: 1776\rAT_HWCAP: 1f8bfbff\rAT_PAGESZ: 4096\rAT_CLKTCK: 100\rAT_PHDR: 0x5640459c7040\rAT_PHENT: 56\rAT_PHNUM: 14\rAT_BASE: 0x7f7134739000\rAT_FLAGS: 0x0\rAT_ENTRY: 0x5640459c8050\rAT_UID: 1000\rAT_EUID: 1000\rAT_GID: 1000\rAT_EGID: 1000\rAT_SECURE: 0\rAT_RANDOM: 0x7ffc2a3ea779\rAT_HWCAP2: 0x0\rAT_EXECFN: ./ELF2\rAT_PLATFORM: x86_64\rAT_??? (0x1b): 0x1c\rAT_??? (0x1c): 0x20\rinit101\rinit102\rinit65535 This vector offers us valuable information. Explanations for each can be found at this link. This __libc_start_main performs the following tasks:\nInitialization:\nRetrieves the values of argv, argc, and .envp. Saves the stack_end. Internal Initialization:\nCalls the functions listed in .init_array for initialization. If the program is static, it also executes the functions in .preinit_array. Additionally, if the _init function exists, it is called before the functions in .init_array. Function Registration:\nRegisters two functions, rtld_fini and call_fini, which are invoked when the program exits. These functions are explained in greater detail in the continuation. Calling call_init After retrieving argv, argc, and envp, the call_init function is invoked by __libc_start_main. The call_init function executes all the functions listed in the .init_array in sequential order:\n→ 0x7ffff7ddcdf2 \u003c__libc_start_main+0052\u003e je 0x7ffff7ddce25 \u003c__libc_start_main_impl+133\u003e The function call_init receives the following arguments:\n[#0] 0x7ffff7ddce25 → call_init(argc=0x1, argv=0x7fffffffde38, env=0x7fffffffde48) For our program, the first function that will be executed is _init:\n→ 0x555555555000 \u003c_init+0000\u003e sub rsp, 0x8\r0x555555555004 \u003c_init+0004\u003e mov rax, QWORD PTR [rip+0x2fc5] # 0x555555557fd0\r0x55555555500b \u003c_init+000b\u003e test rax, rax\r0x55555555500e \u003c_init+000e\u003e je 0x555555555012 \u003c_init+18\u003e\r0x555555555010 \u003c_init+0010\u003e call rax\r0x555555555012 \u003c_init+0012\u003e add rsp, 0x8\r0x555555555016 \u003c_init+0016\u003e ret This function doesn’t actually perform any special actions! Let’s move on to the next function. The next function is init101, which is defined to run before the main function in the program, based on the priority we set earlier:\n→ 0x55555555514f push rbp\r0x555555555150 mov rbp, rsp\r0x555555555153 lea rax, [rip+0xeb2] # 0x55555555600c\r0x55555555515a mov rdi, rax\r0x55555555515d call 0x555555555030 0x555555555162 nop 0x555555555163 pop rbp\r0x555555555164 ret This function is defined in the source code and is invoked by calling puts, which takes the init101 message as a parameter and displays it as output in the terminal. The next function to be executed is init102, which performs the same task as the previous function and displays the corresponding message:\n→ 0x555555555139 push rbp\r0x55555555513a mov rbp, rsp\r0x55555555513d lea rax, [rip+0xec0] # 0x555555556004\r0x555555555144 mov rdi, rax\r0x555555555147 call 0x555555555030 0x55555555514c nop\r0x55555555514d pop rbp\r0x55555555514e ret The next step involves calling the frame_dummy function. The primary objective of this call is to register the frame information for data analysis, ensuring that if an exception occurs, the stack frames can be accurately processed and the point of the exception can be identified. This function prepares the necessary arguments for the main frame registration function, __register_frame_info:\n→ 0x555555555130 endbr64 0x555555555134 jmp 0x5555555550b0 → 0x5555555550b0 lea rdi, [rip+0x2f61] # 0x555555558018 0x5555555550b7 lea rsi, [rip+0x2f5a] # 0x555555558018 0x5555555550be sub rsi, rdi\r0x5555555550c1 mov rax, rsi\r0x5555555550c4 shr rsi, 0x3f\r0x5555555550c8 sar rax, 0x3\r0x5555555550cc add rsi, rax\r0x5555555550cf sar rsi, 1\r0x5555555550d2 je 0x5555555550e8 0x5555555550d4 mov rax, QWORD PTR [rip+0x2efd] # 0x555555557fd8\r0x5555555550db test rax, rax\r0x5555555550de je 0x5555555550e8 0x5555555550e0 jmp rax\r0x5555555550e2 nop WORD PTR [rax+rax*1+0x0]\r0x5555555550e8 ret The last constructor function to be executed is init, serving the same purpose as the previous function defined at the source level:\n→ 0x555555555165 push rbp\r0x555555555166 mov rbp, rsp\r0x555555555169 lea rax, [rip+0xea4] # 0x555555556014\r0x555555555170 mov rdi, rax\r0x555555555173 call 0x555555555030 0x555555555178 nop 0x555555555179 pop rbp\r0x55555555517a ret Calling _dl_audit_preinit@plt The next function is _dl_audit_preinit@plt, which executes the members of the preinit_array array.\nCalling libc_start_call_main Next, we have the libc_start_call_main function, which is responsible for invoking the main function. It takes three parameters, detailed as follows:\n[#0] 0x7ffff7ddccf0 → __libc_start_call_main(main=0x55555555517b , argc=0x1, argv=0x7fffffffde28) The main function simply returns the value zero in the eax register:\n→ 0x55555555517b push rbp\r0x55555555517c mov rbp, rsp\r0x55555555517f mov eax, 0x0\r0x555555555184 pop rbp\r0x555555555185 ret rtld_fini function The rtld_fini function is called by __libc_start_main after the main function has completed. This function is designed to be executed after the program has finished running but before exiting and before call_fini. It is specifically used for dynamically linked programs and performs several important tasks, including:\nUnloading libraries that were loaded during runtime. Calling the destructors for those libraries. Deallocating resources used for loading the libraries. If the program utilized threading, rtld_fini also cleans up thread-specific resources that are reserved for Thread Local Storage (TLS). call_fini function This function is executed after rtld_fini and is responsible for executing the functions in the fini_array section in reverse order. The functions in this section are destructors that clean up the resources allocated during the program’s execution or initialization.\nConclusion Understanding the execution process of a program from the _start function to main reveals the hidden complexities underlying a seemingly simple program. This process involves intricate interactions among the compiler, linker, and operating system, which ensure the correct initialization and termination of resources.\nKey elements such as constructor and destructor functions, as well as section layouts like .ctors, .init_array, and .preinit_array, play crucial roles in managing the lifecycle of a program. The reverse order of constructor execution and the structured handling of destructors further highlight the deliberate design choices intended to maintain consistency and correctness.\nAdditionally, exploring how system calls like execve, along with debugging tools like objdump and GDB, expose the step-by-step execution flow provides invaluable insights into program behavior. This knowledge bridges the gap between high-level programming and the low-level mechanisms that drive modern software.\nIn the next post, we will examine the behind-the-scenes process of the main function until the program concludes.\nLinks https://maskray.me/blog/2021-11-07-init-ctors-init-array https://gcc.gnu.org/onlinedocs/gccint/Initialization.html http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html https://docs.oracle.com/cd/E88353_01/html/E37853/crti.o-7.html https://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-v.html ","wordCount":"4327","inLanguage":"en","image":"https://bitinfiltrator.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-01-25T13:11:18Z","dateModified":"2025-01-25T13:11:18Z","author":{"@type":"Person","name":"Mahdi Davoudabadi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bitinfiltrator.github.io/posts/whatishappeningbeforemainfunc/"},"publisher":{"@type":"Organization","name":"BitInfiltrator","logo":{"@type":"ImageObject","url":"https://bitinfiltrator.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bitinfiltrator.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://bitinfiltrator.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bitinfiltrator.github.io/about/ title=About><span>About</span></a></li><li><a href=https://bitinfiltrator.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://bitinfiltrator.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://bitinfiltrator.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://bitinfiltrator.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bitinfiltrator.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://bitinfiltrator.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">What happens before the main function, from the _start point to the main function?</h1><div class=post-meta><span title='2025-01-25 13:11:18 +0000 UTC'>January 25, 2025</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;4327 words&nbsp;·&nbsp;Mahdi Davoudabadi&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/WhatIsHappeningBeforeMainFunc.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#introducion>Introducion</a></li><li><a href=#how-does-gcc-handle-constructor-and-destructor-functions>How does GCC handle constructor and destructor functions?</a><ul><li><a href=#ctors-and-dtors-sections><code>.ctors</code> and <code>.dtors</code> Sections</a></li><li><a href=#init_array-and-fini_array-sections><code>.init_array</code> and <code>.fini_array</code> Sections</a></li><li><a href=#preinit_array>.preinit_array</a></li></ul></li><li><a href=#what-is-happening-behind-the-scene>What is happening behind the scene?</a><ul><li><a href=#the-_start-function-the-hidden-beginning-of-a-program>The _start Function: The Hidden Beginning of a Program</a></li><li><a href=#how-do-we-get-to-_start>How do we get to _start?</a></li><li><a href=#a-closer-look-at-_start>A Closer Look at _start</a></li><li><a href=#preparing-to-call-the-libc_start_main-function>Preparing to call the <code>libc_start_main</code> function.</a></li><li><a href=#calling-call_init>Calling <code>call_init</code></a></li><li><a href=#calling-libc_start_call_main>Calling <code>libc_start_call_main</code></a></li><li><a href=#rtld_fini-function>rtld_fini function</a></li><li><a href=#call_fini-function>call_fini function</a></li></ul></li><li><a href=#conclusion>Conclusion</a><ul><li><a href=#links>Links</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=introducion>Introducion<a hidden class=anchor aria-hidden=true href=#introducion>#</a></h2><p>For most programmers, the entry point of a C or C++ program is the main function. However, they may be unaware of the complex steps that occur before main is executed. Depending on the program and the compiler used, various functions may run before main. These functions are automatically included in the final executable binary by the compiler and linker, but they remain hidden from the programmer.</p><p>This post discusses the execution process and events from _start to the main function, with future posts covering the next steps.</p><p>Before we dive into the main part, you must have some basic knowledge about constructor and destructors.</p><h2 id=how-does-gcc-handle-constructor-and-destructor-functions>How does GCC handle constructor and destructor functions?<a hidden class=anchor aria-hidden=true href=#how-does-gcc-handle-constructor-and-destructor-functions>#</a></h2><p>In C++, dynamic initialization of non-local variables is performed before the first main function statement is executed. In other words, these variables are initialized before the main program starts running. All (or most) C++ compiler implementations guarantee this.</p><p>The GCC compiler supports <code>__attribute__((constructor))</code>, which allows you to call an arbitrary function before the main function is executed. These functions, called constructors, can have an optional precedence specified using <code>__attribute__((constructor(N)))</code>.</p><p>Priorities ranging from 0 to 100 are reserved for internal compiler use, and utilizing them will trigger the -Wprio-ctor-dtor warning. For instance, the <code>gcov</code> tool uses the attribute <code>__attribute__((destructor(100)))</code>. Programmers can use priorities from 101 to 65535 for their constructor functions. The priority 65535, specified by the .init_array or .ctors sections without an extension, is the default priority for the dynamic initialization of non-local variables.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=nf>__attribute__</span><span class=p>((</span><span class=nf>constructor</span><span class=p>(</span><span class=mi>102</span><span class=p>)))</span> <span class=kt>void</span> <span class=nf>init102</span><span class=p>()</span> <span class=p>{</span> <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;init102&#34;</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>__attribute__</span><span class=p>((</span><span class=nf>constructor</span><span class=p>(</span><span class=mi>101</span><span class=p>)))</span> <span class=kt>void</span> <span class=nf>init101</span><span class=p>()</span> <span class=p>{</span> <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;init101&#34;</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>__attribute__</span><span class=p>((</span><span class=n>constructor</span><span class=p>))</span> <span class=kt>void</span> <span class=nf>init</span><span class=p>()</span> <span class=p>{</span> <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;init65535&#34;</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Constructor functions on ELF platforms are implemented in two ways: the older method uses .init/.ctors, while the newer method utilizes .init_array.</p><h3 id=ctors-and-dtors-sections><code>.ctors</code> and <code>.dtors</code> Sections<a hidden class=anchor aria-hidden=true href=#ctors-and-dtors-sections>#</a></h3><p>In GCC&rsquo;s libgcc/crtstuff.c, when <code>__LIBGCC_INIT_ARRAY_SECTION_ASM_OP__</code> is not defined and <code>__LIBGCC_INIT_SECTION_ASM_OP__</code> is defined (indicating that HAVE_INITFINI_ARRAY_SUPPORT is 1 in $builddir/gcc/auto-host.h), the following scheme is used. Note that this condition is not met on modern systems.</p><p>C++ dynamic initializations and <code>__attribute__((constructor))</code> do not use _init directly.When this condition is met, global constructors and destructors are stored in sections known as .ctors and .dtors, respectively. These sections contain the addresses of these functions, and at runtime, the operating system retrieves these addresses and executes the functions in the specified order. In essence, these sections act as a list of functions that must be called before and after the main program begins execution.</p><p>Imagine we have two object files named c.o and d.o, each containing a .ctors section with different priorities. After linking these files, the resulting .ctors section will be organized as follows:</p><pre tabindex=0><code>crtbegin.o:(.ctors) __CTOR_LIST__
c.o:(.ctors) d.o:(.ctors)
c.o:(.ctors.00001) d.o:(.ctors.00001)
c.o:(.ctors.00002) d.o:(.ctors.00002)
...
c.o:(.ctors.65533) d.o:(.ctors.65533)
c.o:(.ctors.65534) d.o:(.ctors.65534)
...
crtend.o:(.ctors) __CTOR_LIST_END__
</code></pre><p>The .dtors section is organized in the same manner:</p><pre tabindex=0><code>crtbegin.o:(.dtors) __DTOR_LIST__
c.o:(.dtors) d.o:(.dtors)
c.o:(.dtors.00001) d.o:(.dtors.00001)
c.o:(.dtors.00002) d.o:(.dtors.00002)
...
c.o:(.dtors.65533) d.o:(.dtors.65533)
c.o:(.dtors.65534) d.o:(.dtors.65534)
...
crtend.o:(.dtors) __DTOR_LIST_END__
</code></pre><p>The <code>crtbegin.o</code> and <code>crtend.o</code> files play a crucial role in the initialization and termination processes of a program. These files contain specific functions and data that the linker includes in the final executable file.</p><ol><li><p><strong>The <code>crtbegin.o</code> file:</strong></p><ul><li>At the beginning of each <code>.ctors</code> and <code>.dtors</code> section, it places a special value known as the guard element. This value is typically -1 (or its equivalent on 64-bit systems, <code>0xffffffffffffffff</code>) and indicates the start of the list of constructors or destructors.</li><li>The <code>crtbegin.o</code> file also defines a <code>.fini</code> section that calls the <code>__do_global_dtors_aux</code> function. This function is responsible for executing static destructors (functions that free resources) in the correct order.</li></ul></li><li><p><strong>The <code>crtend.o</code> file:</strong></p><ul><li>At the end of each <code>.ctors</code> and <code>.dtors</code> section, it places a special value called the guard element. This value is usually 0, which signifies the end of the constructor or destructor list.</li><li>The <code>crtend.o</code> file also defines an <code>.init</code> section that calls the <code>__do_global_ctors_aux</code> function. This function is responsible for executing static constructors (functions that initialize variables and objects) in the correct order.</li></ul></li></ol><p>The guard elements (-1 and 0) serve as markers to help the linker and operating system identify the beginning and end of the lists of constructors and destructors, respectively. These elements are ignored when the functions are executed.</p><h4 id=reverse-execution-order-of-constructors-and-destructors>Reverse Execution Order of Constructors and Destructors<a hidden class=anchor aria-hidden=true href=#reverse-execution-order-of-constructors-and-destructors>#</a></h4><p>One interesting feature of constructor and destructor execution is their reverse order of execution. Specifically, constructors located in the .ctors section are executed in reverse order, while destructors in the .dtors section are executed in the order in which they were defined.</p><h4 id=why-are-constructors-executed-in-reverse-order>Why Are Constructors Executed in Reverse Order?<a hidden class=anchor aria-hidden=true href=#why-are-constructors-executed-in-reverse-order>#</a></h4><p>This behavior is by design. When dynamically linking libraries, if one library depends on another, the constructors of the dependent library are executed first. For example, if <code>library a.so</code> depends on <code>library b.so</code>, the constructors of <code>b.so</code> are executed before those of <code>a.so</code>. This sequence ensures that each symbol is properly initialized before being used.</p><p>For .ctors sections without an extension (which have the lowest precedence), the order of constructor execution during dynamic linking follows the same pattern as in static linking. This means that when multiple object files are linked together into an executable, the constructors are executed in the order they appear on the command line.</p><p>Destructors serve as a complement to constructors, executing in the order of their creation. This ensures that resources are properly deallocated in the reverse order of how they were allocated.</p><h4 id=why-is-this-order-important>Why Is This Order Important?<a hidden class=anchor aria-hidden=true href=#why-is-this-order-important>#</a></h4><ul><li>It ensures that each symbol is initialized before use.</li><li>It maintains consistent behavior between dynamic and static linking.</li><li>It guarantees the correct deallocation of resources.</li></ul><h3 id=init_array-and-fini_array-sections><code>.init_array</code> and <code>.fini_array</code> Sections<a hidden class=anchor aria-hidden=true href=#init_array-and-fini_array-sections>#</a></h3><p>The developers of HP-UX identified several issues with the use of the <code>.init</code> and <code>.ctors</code> sections:</p><ul><li>The <code>_init</code> function is fragmented and inconsistent, resulting in code that is difficult to read and prone to errors.</li><li>Using sentinel values in the <code>.ctors</code> section is considered poor practice.</li><li>The <code>.init</code> and <code>.ctors</code> sections utilize unconventional naming instead of the defined section types.</li></ul><p>To address these issues, the <code>DT_INIT_ARRAY</code> mechanism was introduced as an alternative. While glibc implemented this method in 1999, both GCC and Binutils had outdated implementations at that time.</p><p>Support for <code>DT_INIT_ARRAY</code> was added to FreeBSD in March 2012, to OpenBSD in August 2016, and to all ports of NetBSD in December 2018.</p><p>In the glibc and BSD implementations, the constructors are invoked with <code>argc</code>, <code>argv</code>, and <code>environ</code> arguments. In contrast, the musl implementation calls constructors without any arguments.</p><p>In this context, the <code>.init_array</code> and <code>.init_array.N</code> sections are designated as type <code>SHT_INIT_ARRAY</code>. Note that <code>crtbegin.o</code> and <code>crtend.o</code> do not provide any segments.</p><p>The layout is as follows:</p><pre tabindex=0><code>a.o:(.init_array.1) b.o:(.init_array.1)
a.o:(.init_array.2) b.o:(.init_array.2)
...
a.o:(.init_array.65533) b.o:(.init_array.65533)
a.o:(.init_array.65534) b.o:(.init_array.65534)
a.o:(.init_array) b.o:(.init_array)
</code></pre><p>The linker defines <code>DT_INIT_ARRAY</code> and <code>DT_INIT_ARRAYSZ</code> based on the address and size of <code>init_array</code>. It also defines <code>init_array_start</code> and <code>init_array_end</code> if they are referenced. These pair of symbols can be used by a statically linked, position-dependent executable that may not include a .dynamic section.</p><p>Unlike <code>.ctors</code>, the execution order of <code>.init_array</code> is linear, following <code>.init</code>. Specifically, the order of execution for <code>a.o:(.init_array) b.o:(.init_array)</code> is different from <code>a.o:(.ctors) b.o:(.ctors)</code>.</p><p>In the GCC compiler, newer ABI implementations, such as AArch64 and RISC-V, exclusively use <code>.init_array</code> and do not include <code>.ctors</code>.</p><h3 id=preinit_array>.preinit_array<a hidden class=anchor aria-hidden=true href=#preinit_array>#</a></h3><p>The linker determines the values of <code>DT_PREINIT_ARRAY</code> and <code>DT_PREINIT_ARRAYSZ</code> based on the address and size of the <code>.preinit_array</code> section. It also defines the symbols <code>__preinit_array_start</code> and <code>__preinit_array_end</code> if they are referenced.</p><p><code>DT_PREINIT_ARRAY</code> contains the address of an array of pointers to pre-initialization functions. The <code>DT_PREINIT_ARRAY</code> table is processed only in executable files and is ignored in shared objects. This feature allows the executable file to run initialization functions before any shared object dependencies are processed. There is no .postfini_array.</p><p>Most implementations of <code>ld.so</code> support <code>DT_PREINIT_ARRAY</code>; however, musl does not support this feature.</p><h2 id=what-is-happening-behind-the-scene>What is happening behind the scene?<a hidden class=anchor aria-hidden=true href=#what-is-happening-behind-the-scene>#</a></h2><p>Let&rsquo;s review the previously written program. This program contains three functions that execute before the main execution and display the corresponding messages. Additionally, the main function in this program does nothing but return 0.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=nf>__attribute__</span><span class=p>((</span><span class=nf>constructor</span><span class=p>(</span><span class=mi>102</span><span class=p>)))</span> <span class=kt>void</span> <span class=nf>init102</span><span class=p>()</span> <span class=p>{</span> <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;init102&#34;</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>__attribute__</span><span class=p>((</span><span class=nf>constructor</span><span class=p>(</span><span class=mi>101</span><span class=p>)))</span> <span class=kt>void</span> <span class=nf>init101</span><span class=p>()</span> <span class=p>{</span> <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;init101&#34;</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>__attribute__</span><span class=p>((</span><span class=n>constructor</span><span class=p>))</span> <span class=kt>void</span> <span class=nf>init</span><span class=p>()</span> <span class=p>{</span> <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;init65535&#34;</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>To include debug information for analysis in our program, we must compile it using the -ggdb switch of the gcc compiler. You can achieve this with the following command:</p><pre tabindex=0><code>gcc -ggdb -o ELF2 ELF_008.c
</code></pre><p>What is the difference between the -g and -ggdb switches?</p><ul><li><p>The -g switch instructs the compiler to generate debugging information in standard operating system formats such as stabs, COFF, XCOFF, or DWARF. This information helps debugging tools like GDB to better understand and debug the program.</p></li><li><p>The -ggdb switch produces a more comprehensive level of debugging information specifically designed for GDB. This allows GDB to extract additional information about the program, enabling more detailed debugging.</p></li></ul><p>Before we debug the program in gdb, let&rsquo;s first examine how a C program is executed from the beginning. We can use the <code>objdump</code> tool to convert machine code into assembly code. The following command saves the disassembly output of an ELF2 program to a file named ELF2.dump:</p><pre tabindex=0><code>objdump -d ELF2 &gt; ELF2.dump
</code></pre><p>The file named prog1.dump contains assembly instructions that the processor executes directly. Here is a brief overview of the functions that we will review shortly:</p><pre tabindex=0><code>ELF2:     file format elf64-x86-64

0000000000001050 &lt;_start&gt;:
    1050:	31 ed                	xor    %ebp,%ebp
    1052:	49 89 d1             	mov    %rdx,%r9
    1055:	5e                   	pop    %rsi
    1056:	48 89 e2             	mov    %rsp,%rdx
    1059:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
    105d:	50                   	push   %rax
    105e:	54                   	push   %rsp
    105f:	45 31 c0             	xor    %r8d,%r8d
    1062:	31 c9                	xor    %ecx,%ecx
    1064:	48 8d 3d 10 01 00 00 	lea    0x110(%rip),%rdi        # 117b &lt;main&gt;
    106b:	ff 15 4f 2f 00 00    	call   *0x2f4f(%rip)        # 3fc0 &lt;__libc_start_main@GLIBC_2.34&gt;
    1071:	f4                   	hlt
    1072:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    1079:	00 00 00 
    107c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000001139 &lt;init102&gt;:
    1139:	55                   	push   %rbp
    113a:	48 89 e5             	mov    %rsp,%rbp
    113d:	48 8d 05 c0 0e 00 00 	lea    0xec0(%rip),%rax        # 2004 &lt;_IO_stdin_used+0x4&gt;
    1144:	48 89 c7             	mov    %rax,%rdi
    1147:	e8 e4 fe ff ff       	call   1030 &lt;puts@plt&gt;
    114c:	90                   	nop
    114d:	5d                   	pop    %rbp
    114e:	c3                   	ret

000000000000114f &lt;init101&gt;:
    114f:	55                   	push   %rbp
    1150:	48 89 e5             	mov    %rsp,%rbp
    1153:	48 8d 05 b2 0e 00 00 	lea    0xeb2(%rip),%rax        # 200c &lt;_IO_stdin_used+0xc&gt;
    115a:	48 89 c7             	mov    %rax,%rdi
    115d:	e8 ce fe ff ff       	call   1030 &lt;puts@plt&gt;
    1162:	90                   	nop
    1163:	5d                   	pop    %rbp
    1164:	c3                   	ret

0000000000001165 &lt;init&gt;:
    1165:	55                   	push   %rbp
    1166:	48 89 e5             	mov    %rsp,%rbp
    1169:	48 8d 05 a4 0e 00 00 	lea    0xea4(%rip),%rax        # 2014 &lt;_IO_stdin_used+0x14&gt;
    1170:	48 89 c7             	mov    %rax,%rdi
    1173:	e8 b8 fe ff ff       	call   1030 &lt;puts@plt&gt;
    1178:	90                   	nop
    1179:	5d                   	pop    %rbp
    117a:	c3                   	ret

000000000000117b &lt;main&gt;:
    117b:	55                   	push   %rbp
    117c:	48 89 e5             	mov    %rsp,%rbp
    117f:	b8 00 00 00 00       	mov    $0x0,%eax
    1184:	5d                   	pop    %rbp
    1185:	c3                   	ret

...
</code></pre><h3 id=the-_start-function-the-hidden-beginning-of-a-program>The _start Function: The Hidden Beginning of a Program<a hidden class=anchor aria-hidden=true href=#the-_start-function-the-hidden-beginning-of-a-program>#</a></h3><p>In most C and C++ programs, the actual starting point of execution is a function called <code>_start</code>. This function is responsible for setting up the program&rsquo;s execution environment and for calling the <code>main</code> function, which serves as the logical starting point for the programmer.</p><p>While it is a common convention to use <code>_start</code> as the main entry point, it is not a strict requirement. Depending on the operating system, compiler, and libraries utilized, a different entry point may be specified. For instance, on macOS, the <code>main</code> function itself serves as the entry point, with the operating system taking care of preparing the execution environment.</p><p>The linker plays a crucial role in determining a program&rsquo;s entry point. By default, linkers such as Clang and GCC set the entry point to the <code>_start</code> function. However, this can be altered using the <code>-e</code> switch, although such changes are typically unnecessary.</p><p>The <code>_start</code> function is usually implemented and provided in the C standard library (libc) and is often written in assembly language. This code is found in a file named <code>crt0.s</code>, and compilers generally provide precompiled versions of this file for various architectures.</p><h3 id=how-do-we-get-to-_start>How do we get to _start?<a hidden class=anchor aria-hidden=true href=#how-do-we-get-to-_start>#</a></h3><p>When you run a Linux program, the shell or graphical user interface (GUI) calls the <code>execve()</code> function, which executes the Linux <code>execve()</code> system call.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execve</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>_Nullable</span> <span class=n>argv</span><span class=p>[],</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>_Nullable</span> <span class=n>envp</span><span class=p>[]);</span>
</span></span></code></pre></div><p>The execve function replaces the currently running program with the program specified by the pathname. The current program is the process that invoked the execve system call, which in this case is the shell or GUI. In other words, the new program takes the place of the previous one, creating a new memory space for itself, which includes a stack, heap, and data sections (both initialized and uninitialized).</p><p>The pathname must be an executable binary file or a script that begins with a line in the following format:</p><pre tabindex=0><code>#!interpreter [optional-arg]
</code></pre><p>The argv variable is an array containing the arguments provided on the command line when running the program. Each element of this array is a string representing an argument. For instance, if we run a program called myprogram with the arguments -a and data.txt, the argv array will look like this:</p><pre tabindex=0><code>argv[0] = &#34;myprogram&#34;;
argv[1] = &#34;-a&#34;;
argv[2] = &#34;data.txt&#34;;
argv[3] = NULL;
</code></pre><p>The envp variable is an array of pointers to strings that contains environment variables passed to the new program. These environment variables function like system variables, and each element of this array is a string formatted as key=value. For example:</p><pre tabindex=0><code>envp[0] = &#34;PATH=/bin:/usr/bin&#34;;
envp[1] = &#34;HOME=/home/user&#34;;
envp[2] = NULL; 
</code></pre><p>When execve is successfully executed, the new program completely replaces the previous one, and all the resources of the previous program are freed. This means that the execve function never returns to the calling program; instead, the memory space of the previous program is replaced with that of the new program. Additionally, if the previous program is being traced (using ptrace), a SIGTRAP signal is sent to it after the successful execution of execve.</p><p>Following this, the loader is responsible for loading the program into memory and setting up memory addresses. The loader may also perform some initial tasks, such as calling certain functions, before the program begins executing. Once everything is ready, control of the program execution is transferred to a function called _start.</p><p>For more information about the execve system call, please refer to this <a href=https://man7.org/linux/man-pages/man2/execve.2.html>link</a>.</p><h3 id=a-closer-look-at-_start>A Closer Look at _start<a hidden class=anchor aria-hidden=true href=#a-closer-look-at-_start>#</a></h3><p>First, we run the program in GDB using the following command:</p><pre tabindex=0><code>gdb ./ELF2
</code></pre><p>Next, we set a breakpoint at the beginning of the <code>_start</code> function and run the program:</p><pre tabindex=0><code>b _start
r
</code></pre><p>Once we reach the <code>_start</code> function, the program stack appears as follows:</p><pre tabindex=0><code>+-----------------+
|       NULL      |
+-----------------+ 
|       ...       |
|       envp      |
|       ...       |
+-----------------+ 
|       NULL      |
+------------------
|       ...       |
|       argv      |
|       ...       |
+------------------
|       argc      | &lt;- rsp
+-----------------+
</code></pre><p>Below, you can see the structure of the _start function for the program we compiled using GCC:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=err>●</span> <span class=err>→</span><span class=mh>0x555555555050</span> <span class=o>&lt;</span><span class=n>_start</span><span class=o>+</span><span class=mo>0000</span><span class=o>&gt;</span>    <span class=n>xor</span>    <span class=n>ebp</span><span class=p>,</span> <span class=n>ebp</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x555555555052</span> <span class=o>&lt;</span><span class=n>_start</span><span class=o>+</span><span class=mo>0002</span><span class=o>&gt;</span>    <span class=n>mov</span>    <span class=n>r9</span><span class=p>,</span> <span class=n>rdx</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x555555555055</span> <span class=o>&lt;</span><span class=n>_start</span><span class=o>+</span><span class=mo>0005</span><span class=o>&gt;</span>    <span class=n>pop</span>    <span class=n>rsi</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x555555555056</span> <span class=o>&lt;</span><span class=n>_start</span><span class=o>+</span><span class=mo>0006</span><span class=o>&gt;</span>    <span class=n>mov</span>    <span class=n>rdx</span><span class=p>,</span> <span class=n>rsp</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x555555555059</span> <span class=o>&lt;</span><span class=n>_start</span><span class=o>+</span><span class=mo>000</span><span class=mi>9</span><span class=o>&gt;</span>    <span class=n>and</span>    <span class=n>rsp</span><span class=p>,</span> <span class=mh>0xfffffffffffffff0</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x55555555505d</span> <span class=o>&lt;</span><span class=n>_start</span><span class=o>+</span><span class=mo>000</span><span class=n>d</span><span class=o>&gt;</span>    <span class=n>push</span>   <span class=n>rax</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x55555555505e</span> <span class=o>&lt;</span><span class=n>_start</span><span class=o>+</span><span class=mo>000</span><span class=n>e</span><span class=o>&gt;</span>    <span class=n>push</span>   <span class=n>rsp</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x55555555505f</span> <span class=o>&lt;</span><span class=n>_start</span><span class=o>+</span><span class=mf>000f</span><span class=o>&gt;</span>    <span class=n>xor</span>    <span class=n>r8d</span><span class=p>,</span> <span class=n>r8d</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x555555555062</span> <span class=o>&lt;</span><span class=n>_start</span><span class=o>+</span><span class=mo>0012</span><span class=o>&gt;</span>    <span class=n>xor</span>    <span class=n>ecx</span><span class=p>,</span> <span class=n>ecx</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x555555555064</span> <span class=o>&lt;</span><span class=n>_start</span><span class=o>+</span><span class=mo>0014</span><span class=o>&gt;</span>    <span class=n>lea</span>    <span class=n>rdi</span><span class=p>,</span> <span class=p>[</span><span class=n>rip</span><span class=o>+</span><span class=mh>0x110</span><span class=p>]</span>        <span class=err>#</span> <span class=mh>0x55555555517b</span> <span class=o>&lt;</span><span class=n>main</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x55555555506b</span> <span class=o>&lt;</span><span class=n>_start</span><span class=o>+</span><span class=mo>001</span><span class=n>b</span><span class=o>&gt;</span>    <span class=n>call</span>   <span class=n>QWORD</span> <span class=n>PTR</span> <span class=p>[</span><span class=n>rip</span><span class=o>+</span><span class=mh>0x2f4f</span><span class=p>]</span>        <span class=err>#</span> <span class=mh>0x555555557fc0</span>
</span></span><span class=line><span class=cl>   <span class=mh>0x555555555071</span> <span class=o>&lt;</span><span class=n>_start</span><span class=o>+</span><span class=mo>0021</span><span class=o>&gt;</span>    <span class=n>hlt</span>  
</span></span></code></pre></div><ol><li><p>At the beginning of this code, the <code>ebp</code> register is set to zero using the <code>xor ebp, ebp</code> instruction. This zero value in the <code>ebp</code> register indicates the start of a new stack frame.</p></li><li><p>The value in the <code>rdx</code> register, which is being transferred to <code>r9</code>, corresponds to the <code>dl_fini</code> function. This function serves as a parameter to the <code>__libc_start_main</code> function.</p></li><li><p>The value of <code>argc</code> is removed from the top of the stack and placed into the <code>rsi</code> register.</p></li><li><p>Next, the instruction <code>mov rdx, rsp</code> is used to transfer the address of the <code>argv</code> parameter into the <code>rdx</code> register.</p></li><li><p>An AND operation is then performed between the <code>rsp</code> register and the value <code>0xffffffffffffff0</code>. The purpose of this operation is to align the stack to a 16-byte boundary. After popping the <code>argc</code> value from the stack, the <code>esp</code> value changes from <code>0xbffff770</code> to <code>0xbffff774</code>. The AND operation restores the <code>rsp</code> value back to <code>0xbffff770</code>.</p></li><li><p>Finally, the starting address of the <code>envp</code> array is pushed onto the stack.</p></li><li><p>Note that the r8 and ecx registers are for the init and fini function parameters, and these parameters are set to zero.</p></li></ol><p>In older versions of GCC (2.34 and earlier), the parameters for init and fini were passed as the addresses of the first instructions of the functions <code>__libc_csu_init</code> and <code>__libc_csu_fini</code>, respectively. However, with changes, these two functions have been removed. The responsibilities for processing the <code>init_array</code>, <code>fini_array</code>, and <code>preinit_array</code> arrays have now been divided into different sections of the <code>libc_start_main</code> function. As a result of the removal of these functions, null values are passed to the <code>libc_start_main</code> function for the init and fini parameters instead of the addresses of <code>__libc_csu_init</code> and <code>__libc_csu_fini</code>.</p><h4 id=the-question-arises-how-do-we-determine-the-locations-of-argc-argv-and-envp>The question arises: how do we determine the locations of argc, argv, and envp?<a hidden class=anchor aria-hidden=true href=#the-question-arises-how-do-we-determine-the-locations-of-argc-argv-and-envp>#</a></h4><p>Before the _start function is called, these three values are placed on the stack as pointers. To understand this, we should examine the contents of the rsp register:
<img alt=image loading=lazy src=/images/image1.png>
As it shown in the image, the value of <code>argc</code> is represented by the number 1, indicating that it was executed without any additional parameters. Consequently, this parameter value will be stored on the stack at the address <code>0x00007fffffffe1b0</code>. If we display the value located at this address as a string, we can observe <code>argv</code>, and <code>envp</code> is placed on the stack after <code>argv</code>.</p><p>As shown in the image, the value of <code>argc</code> is 1, indicating that the program was executed without any additional parameters. This value will be stored on the stack at the address <code>0x00007fffffffe1b0</code>. If we display the value stored at this address as a string, we can see <code>argv</code>, while <code>envp</code> is placed on the stack following <code>argv</code>.</p><h3 id=preparing-to-call-the-libc_start_main-function>Preparing to call the <code>libc_start_main</code> function.<a hidden class=anchor aria-hidden=true href=#preparing-to-call-the-libc_start_main-function>#</a></h3><p>At this stage, the arguments required for the <code>libc_start_main</code> function call are pushed onto the stack in reverse order. The first argument placed on the stack is an arbitrary value, typically stored in the <code>rax</code> register. This value is pushed onto the stack solely for the purpose of maintaining 16-byte alignment and serves no other function. It is essential to maintain this alignment because the subsequent arguments are pushed onto the stack in order, and the additional value ensures proper memory alignment.</p><p>The structure of the <code>__libc_start_main</code> function is as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>int</span> <span class=nf>__libc_start_main</span><span class=p>(</span>  <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>main</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span> <span class=o>*</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span> <span class=o>*</span><span class=p>),</span>
</span></span><span class=line><span class=cl>			    <span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span> <span class=o>*</span> <span class=n>ubp_av</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>init</span><span class=p>)</span> <span class=p>(</span><span class=kt>void</span><span class=p>),</span>
</span></span><span class=line><span class=cl>			    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>fini</span><span class=p>)</span> <span class=p>(</span><span class=kt>void</span><span class=p>),</span>
</span></span><span class=line><span class=cl>			    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>rtld_fini</span><span class=p>)</span> <span class=p>(</span><span class=kt>void</span><span class=p>),</span>
</span></span><span class=line><span class=cl>			    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span> <span class=n>stack_end</span><span class=p>));</span>
</span></span></code></pre></div><p>So, the _start function is expected to push this argument onto the stack in reverse order. The register values before the call looks like this:</p><table><thead><tr><th>registers</th><th>values</th></tr></thead><tbody><tr><td>rdi</td><td>a pointer to the first instruction of the main function</td></tr><tr><td>rsi</td><td>argc value</td></tr><tr><td>rdx</td><td>pointer to argv</td></tr><tr><td>rcx</td><td>null value</td></tr><tr><td>r8</td><td>null value</td></tr><tr><td>r9</td><td>a pointer to the dl_fini/rtld_fini function</td></tr></tbody></table><h4 id=where-are-the-environment-variables-envp>Where are the environment variables (envp)?<a hidden class=anchor aria-hidden=true href=#where-are-the-environment-variables-envp>#</a></h4><p>As mentioned, the envp array is stored on the stack right after the argv array. By using argc, we can determine the number of elements in the argv array, which allows us to find the end of this array and access the envp array. In the image below,at line 244, you can see how __libc_start_main extracts envp at the source code level:</p><p><img alt=image loading=lazy src=/images/image2.png>
After that, you can see that the pointer to the environment variables is stored in a variable named __environ. This variable is accessible throughout the program and is utilized by other C library functions to access environment variables. Whenever <code>libc_start_main</code> requires it—such as when it calls the <code>main</code> function it can reference <code>__environ</code>. Additionally, there&rsquo;s another vector following the <code>envp</code> array known as the ELF auxiliary vector. The loader uses this vector to provide various information to our process. You can view this information by using the command <code>LD_SHOW_AUXV=1</code>:</p><pre tabindex=0><code>LD_SHOW_AUXV=1 ./ELF2
AT_SYSINFO_EHDR:      0x7f7134737000
AT_MINSIGSTKSZ:       1776
AT_HWCAP:             1f8bfbff
AT_PAGESZ:            4096
AT_CLKTCK:            100
AT_PHDR:              0x5640459c7040
AT_PHENT:             56
AT_PHNUM:             14
AT_BASE:              0x7f7134739000
AT_FLAGS:             0x0
AT_ENTRY:             0x5640459c8050
AT_UID:               1000
AT_EUID:              1000
AT_GID:               1000
AT_EGID:              1000
AT_SECURE:            0
AT_RANDOM:            0x7ffc2a3ea779
AT_HWCAP2:            0x0
AT_EXECFN:            ./ELF2
AT_PLATFORM:          x86_64
AT_??? (0x1b): 0x1c
AT_??? (0x1c): 0x20
init101
init102
init65535
</code></pre><p>This vector offers us valuable information. Explanations for each can be found at this <a href=https://man7.org/linux/man-pages/man3/getauxval.3.html>link</a>.
This __libc_start_main performs the following tasks:</p><ol><li><p><strong>Initialization:</strong></p><ul><li>Retrieves the values of <code>argv</code>, <code>argc</code>, and <code>.envp</code>.</li><li>Saves the <code>stack_end</code>.</li></ul></li><li><p><strong>Internal Initialization:</strong></p><ul><li>Calls the functions listed in <code>.init_array</code> for initialization.</li><li>If the program is static, it also executes the functions in <code>.preinit_array</code>.</li><li>Additionally, if the <code>_init</code> function exists, it is called before the functions in <code>.init_array</code>.</li></ul></li><li><p><strong>Function Registration:</strong></p><ul><li>Registers two functions, <code>rtld_fini</code> and <code>call_fini</code>, which are invoked when the program exits. These functions are explained in greater detail in the continuation.</li></ul></li></ol><h3 id=calling-call_init>Calling <code>call_init</code><a hidden class=anchor aria-hidden=true href=#calling-call_init>#</a></h3><p>After retrieving argv, argc, and envp, the call_init function is invoked by __libc_start_main. The <code>call_init</code> function executes all the functions listed in the <code>.init_array</code> in sequential order:</p><pre tabindex=0><code>→ 0x7ffff7ddcdf2 &lt;__libc_start_main+0052&gt; je     0x7ffff7ddce25 &lt;__libc_start_main_impl+133&gt;
</code></pre><p>The function <code>call_init</code> receives the following arguments:</p><pre tabindex=0><code>[#0] 0x7ffff7ddce25 → call_init(argc=0x1, argv=0x7fffffffde38, env=0x7fffffffde48)
</code></pre><p>For our program, the first function that will be executed is _init:</p><pre tabindex=0><code> → 0x555555555000 &lt;_init+0000&gt;     sub    rsp, 0x8
   0x555555555004 &lt;_init+0004&gt;     mov    rax, QWORD PTR [rip+0x2fc5]        # 0x555555557fd0
   0x55555555500b &lt;_init+000b&gt;     test   rax, rax
   0x55555555500e &lt;_init+000e&gt;     je     0x555555555012 &lt;_init+18&gt;
   0x555555555010 &lt;_init+0010&gt;     call   rax
   0x555555555012 &lt;_init+0012&gt;     add    rsp, 0x8
   0x555555555016 &lt;_init+0016&gt;     ret 
</code></pre><p>This function doesn&rsquo;t actually perform any special actions! Let&rsquo;s move on to the next function. The next function is init101, which is defined to run before the main function in the program, based on the priority we set earlier:</p><pre tabindex=0><code> → 0x55555555514f &lt;init101+0000&gt;   push   rbp
   0x555555555150 &lt;init101+0001&gt;   mov    rbp, rsp
   0x555555555153 &lt;init101+0004&gt;   lea    rax, [rip+0xeb2]        # 0x55555555600c
   0x55555555515a &lt;init101+000b&gt;   mov    rdi, rax
   0x55555555515d &lt;init101+000e&gt;   call   0x555555555030 &lt;puts@plt&gt;
   0x555555555162 &lt;init101+0013&gt;   nop       
   0x555555555163 &lt;init101+0014&gt;   pop    rbp
   0x555555555164 &lt;init101+0015&gt;   ret 
</code></pre><p>This function is defined in the source code and is invoked by calling <code>puts</code>, which takes the <code>init101</code> message as a parameter and displays it as output in the terminal.
The next function to be executed is init102, which performs the same task as the previous function and displays the corresponding message:</p><pre tabindex=0><code> → 0x555555555139 &lt;init102+0000&gt;   push   rbp
   0x55555555513a &lt;init102+0001&gt;   mov    rbp, rsp
   0x55555555513d &lt;init102+0004&gt;   lea    rax, [rip+0xec0]        # 0x555555556004
   0x555555555144 &lt;init102+000b&gt;   mov    rdi, rax
   0x555555555147 &lt;init102+000e&gt;   call   0x555555555030 &lt;puts@plt&gt;
   0x55555555514c &lt;init102+0013&gt;   nop
   0x55555555514d &lt;init102+0014&gt;   pop    rbp
   0x55555555514e &lt;init102+0015&gt;   ret 
</code></pre><p>The next step involves calling the <code>frame_dummy</code> function. The primary objective of this call is to register the frame information for data analysis, ensuring that if an exception occurs, the stack frames can be accurately processed and the point of the exception can be identified. This function prepares the necessary arguments for the main frame registration function, <code>__register_frame_info</code>:</p><pre tabindex=0><code> → 0x555555555130 &lt;frame_dummy+0000&gt; endbr64 
   0x555555555134 &lt;frame_dummy+0004&gt; jmp    0x5555555550b0 &lt;register_tm_clones&gt;


 → 0x5555555550b0 &lt;register_tm_clones+0000&gt; lea    rdi, [rip+0x2f61]        # 0x555555558018 &lt;completed.0&gt;
   0x5555555550b7 &lt;register_tm_clones+0007&gt; lea    rsi, [rip+0x2f5a]        # 0x555555558018 &lt;completed.0&gt;
   0x5555555550be &lt;register_tm_clones+000e&gt; sub    rsi, rdi
   0x5555555550c1 &lt;register_tm_clones+0011&gt; mov    rax, rsi
   0x5555555550c4 &lt;register_tm_clones+0014&gt; shr    rsi, 0x3f
   0x5555555550c8 &lt;register_tm_clones+0018&gt; sar    rax, 0x3
   0x5555555550cc &lt;register_tm_clones+001c&gt; add    rsi, rax
   0x5555555550cf &lt;register_tm_clones+001f&gt; sar    rsi, 1
   0x5555555550d2 &lt;register_tm_clones+0022&gt; je     0x5555555550e8 &lt;register_tm_clones+56&gt;
   0x5555555550d4 &lt;register_tm_clones+0024&gt; mov    rax, QWORD PTR [rip+0x2efd]        # 0x555555557fd8
   0x5555555550db &lt;register_tm_clones+002b&gt; test   rax, rax
   0x5555555550de &lt;register_tm_clones+002e&gt; je     0x5555555550e8 &lt;register_tm_clones+56&gt;
   0x5555555550e0 &lt;register_tm_clones+0030&gt; jmp    rax
   0x5555555550e2 &lt;register_tm_clones+0032&gt; nop    WORD PTR [rax+rax*1+0x0]
   0x5555555550e8 &lt;register_tm_clones+0038&gt; ret 
</code></pre><p>The last constructor function to be executed is <code>init</code>, serving the same purpose as the previous function defined at the source level:</p><pre tabindex=0><code> → 0x555555555165 &lt;init+0000&gt;      push   rbp
   0x555555555166 &lt;init+0001&gt;      mov    rbp, rsp
   0x555555555169 &lt;init+0004&gt;      lea    rax, [rip+0xea4]        # 0x555555556014
   0x555555555170 &lt;init+000b&gt;      mov    rdi, rax
   0x555555555173 &lt;init+000e&gt;      call   0x555555555030 &lt;puts@plt&gt;
   0x555555555178 &lt;init+0013&gt;      nop    
   0x555555555179 &lt;init+0014&gt;      pop    rbp
   0x55555555517a &lt;init+0015&gt;      ret
</code></pre><h4 id=calling-_dl_audit_preinitplt>Calling <code>_dl_audit_preinit@plt</code><a hidden class=anchor aria-hidden=true href=#calling-_dl_audit_preinitplt>#</a></h4><p>The next function is <code>_dl_audit_preinit@plt</code>, which executes the members of the preinit_array array.</p><h3 id=calling-libc_start_call_main>Calling <code>libc_start_call_main</code><a hidden class=anchor aria-hidden=true href=#calling-libc_start_call_main>#</a></h3><p>Next, we have the <code>libc_start_call_main</code> function, which is responsible for invoking the main function. It takes three parameters, detailed as follows:</p><pre tabindex=0><code>[#0] 0x7ffff7ddccf0 → __libc_start_call_main(main=0x55555555517b &lt;main&gt;, argc=0x1, argv=0x7fffffffde28)
</code></pre><p>The main function simply returns the value zero in the eax register:</p><pre tabindex=0><code> → 0x55555555517b &lt;main+0000&gt;      push   rbp
   0x55555555517c &lt;main+0001&gt;      mov    rbp, rsp
   0x55555555517f &lt;main+0004&gt;      mov    eax, 0x0
   0x555555555184 &lt;main+0009&gt;      pop    rbp
   0x555555555185 &lt;main+000a&gt;      ret    
</code></pre><h3 id=rtld_fini-function>rtld_fini function<a hidden class=anchor aria-hidden=true href=#rtld_fini-function>#</a></h3><p>The <code>rtld_fini</code> function is called by <code>__libc_start_main</code> after the <code>main</code> function has completed. This function is designed to be executed after the program has finished running but before exiting and before <code>call_fini</code>. It is specifically used for dynamically linked programs and performs several important tasks, including:</p><ul><li>Unloading libraries that were loaded during runtime.</li><li>Calling the destructors for those libraries.</li><li>Deallocating resources used for loading the libraries.</li><li>If the program utilized threading, <code>rtld_fini</code> also cleans up thread-specific resources that are reserved for Thread Local Storage (TLS).</li></ul><h3 id=call_fini-function>call_fini function<a hidden class=anchor aria-hidden=true href=#call_fini-function>#</a></h3><p>This function is executed after <code>rtld_fini</code> and is responsible for executing the functions in the <code>fini_array</code> section in reverse order. The functions in this section are destructors that clean up the resources allocated during the program&rsquo;s execution or initialization.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Understanding the execution process of a program from the <code>_start</code> function to <code>main</code> reveals the hidden complexities underlying a seemingly simple program. This process involves intricate interactions among the compiler, linker, and operating system, which ensure the correct initialization and termination of resources.</p><p>Key elements such as constructor and destructor functions, as well as section layouts like <code>.ctors</code>, <code>.init_array</code>, and <code>.preinit_array</code>, play crucial roles in managing the lifecycle of a program. The reverse order of constructor execution and the structured handling of destructors further highlight the deliberate design choices intended to maintain consistency and correctness.</p><p>Additionally, exploring how system calls like <code>execve</code>, along with debugging tools like <code>objdump</code> and <code>GDB</code>, expose the step-by-step execution flow provides invaluable insights into program behavior. This knowledge bridges the gap between high-level programming and the low-level mechanisms that drive modern software.</p><p>In the next post, we will examine the behind-the-scenes process of the <code>main</code> function until the program concludes.</p><h3 id=links>Links<a hidden class=anchor aria-hidden=true href=#links>#</a></h3><ol><li><a href=https://maskray.me/blog/2021-11-07-init-ctors-init-array>https://maskray.me/blog/2021-11-07-init-ctors-init-array</a></li><li><a href=https://gcc.gnu.org/onlinedocs/gccint/Initialization.html>https://gcc.gnu.org/onlinedocs/gccint/Initialization.html</a></li><li><a href=http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html>http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html</a></li><li><a href=https://docs.oracle.com/cd/E88353_01/html/E37853/crti.o-7.html>https://docs.oracle.com/cd/E88353_01/html/E37853/crti.o-7.html</a></li><li><a href=https://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-v.html>https://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-v.html</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://bitinfiltrator.github.io/tags/binary/>Binary</a></li><li><a href=https://bitinfiltrator.github.io/tags/elf-file-format/>ELF File Format</a></li><li><a href=https://bitinfiltrator.github.io/tags/gcc/>GCC</a></li><li><a href=https://bitinfiltrator.github.io/tags/reverse-engineering/>Reverse Engineering</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share What happens before the main function, from the _start point to the main function? on x" href="https://x.com/intent/tweet/?text=What%20happens%20before%20the%20main%20function%2c%20from%20the%20_start%20point%20to%20the%20main%20function%3f&amp;url=https%3a%2f%2fbitinfiltrator.github.io%2fposts%2fwhatishappeningbeforemainfunc%2f&amp;hashtags=binary%2cELFFileFormat%2cGCC%2cReverseEngineering"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share What happens before the main function, from the _start point to the main function? on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fbitinfiltrator.github.io%2fposts%2fwhatishappeningbeforemainfunc%2f&amp;title=What%20happens%20before%20the%20main%20function%2c%20from%20the%20_start%20point%20to%20the%20main%20function%3f&amp;summary=What%20happens%20before%20the%20main%20function%2c%20from%20the%20_start%20point%20to%20the%20main%20function%3f&amp;source=https%3a%2f%2fbitinfiltrator.github.io%2fposts%2fwhatishappeningbeforemainfunc%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share What happens before the main function, from the _start point to the main function? on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fbitinfiltrator.github.io%2fposts%2fwhatishappeningbeforemainfunc%2f&title=What%20happens%20before%20the%20main%20function%2c%20from%20the%20_start%20point%20to%20the%20main%20function%3f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share What happens before the main function, from the _start point to the main function? on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fbitinfiltrator.github.io%2fposts%2fwhatishappeningbeforemainfunc%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share What happens before the main function, from the _start point to the main function? on whatsapp" href="https://api.whatsapp.com/send?text=What%20happens%20before%20the%20main%20function%2c%20from%20the%20_start%20point%20to%20the%20main%20function%3f%20-%20https%3a%2f%2fbitinfiltrator.github.io%2fposts%2fwhatishappeningbeforemainfunc%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share What happens before the main function, from the _start point to the main function? on telegram" href="https://telegram.me/share/url?text=What%20happens%20before%20the%20main%20function%2c%20from%20the%20_start%20point%20to%20the%20main%20function%3f&amp;url=https%3a%2f%2fbitinfiltrator.github.io%2fposts%2fwhatishappeningbeforemainfunc%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share What happens before the main function, from the _start point to the main function? on ycombinator" href="https://news.ycombinator.com/submitlink?t=What%20happens%20before%20the%20main%20function%2c%20from%20the%20_start%20point%20to%20the%20main%20function%3f&u=https%3a%2f%2fbitinfiltrator.github.io%2fposts%2fwhatishappeningbeforemainfunc%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bitinfiltrator.github.io/>BitInfiltrator</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>